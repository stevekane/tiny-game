{
  "name": "keydrown",
  "version": "0.1.4",
  "main": "./dist/keydrown.min.js",
  "gitHead": "50a181c2fd216317a9b8f2e571524a4346f61576",
  "readme": "# Keydrown\n\n## A JavaScript key state handler for web apps\n\nWhen building games or any application that requires quick reactions from the\nuser, a system to track key states is needed.  You might say \"Silly developer!\nThere are events for that! They're called `keydown` and `keyup`!\"  This is\ncorrect, but the problem that Keydrown solves is more subtle: When you press\nand hold any key on the keyboard, there is a brief delay between the initial\nfiring of the `keydown` event handler and the subsequent firings of that event\nfor every tick.  Here's an approximate ASCII visualization:\n\n````\nTIME (seconds)           KEYDOWN HANDLER FIRING STATE\n-----------------------------------------------------\n\n0                        Firing\n0.25                     Not firing\n0.50                     Not firing\n0.75                     Not firing\n1                        Firing\n1.25                     Firing\n1.50                     Firing\n1.75                     Firing\n2                        Firing\n````\n\n...And the handler will just keep firing until the button is released.  The\nexpectation from the user is that the key handler would be firing for the\nentire duration of time that the key is held down - the early ticks where the\n`keydown` state is not handled creates a feeling of sluggishness and noticeably\nworsens the User Experience.  A way around this delay is to only listen for one\n`keydown` event for a button, and execute the key handler on every tick until\nthe corresponding `keyup` event is detected for that button.\n\nKeydrown makes this super easy.\n\n## API\n\nAll Keydrown functionality exists under the `kd` namespace.\n\n### Key Objects\n\nEvery letter key, as well as some other keys on the keyboard are represented in\na map of `kd.Key` instances with uppercase key names:\n\n````javascript\nkd.A instanceof kd.Key; // true\nkd.SPACE instanceof kd.Key; // true\nkd.UP instanceof kd.Key; // true\n````\n\nYou can see the full list of supported keys in\n[`kd.map.js`](https://github.com/jeremyckahn/keydrown/blob/master/src/kd.map.js)\n(more key codes can easily be added, please submit a Pull Request if you add\nmore).\n[`kd.Key`](http://jeremyckahn.github.io/keydrown/dist/doc/src/kd.key.js.html)\nhas the following API:\n\n````javascript\n/**\n * @param {function=} opt_handler\n */\nkd.Key.prototype.down = function (opt_handler)\n````\n\n`opt_handler` fires for every tick where the key is held down.  There is\nno early delay, as described in the ASCII graph above.  Calling this method for\na key again will overwrite the previous `opt_handler` - only one handler\nfunction is allowed per key.\n\nIf `opt_handler` is omitted, this function invokes whatever handler function\nwas previously bound with `kd.Key#down`.\n\n````javascript\n/**\n * @param {function=} opt_handler\n */\nkd.Key.prototype.up = function (opt_handler)\n````\n\n`opt_handler` fires when the key is released by the user.  As with\n`kd.Key#down`, only one handler function is allowed.  Unlike `kd.Key#down`,\n`opt_handler` does not fire continuously — only once when the key is released.\n\nIf `opt_handler` is omitted, this function invokes whatever handler function\nwas previously bound with `kd.Key#up`.\n\n````javascript\n/**\n * @param {function=} opt_handler\n */\nkd.Key.prototype.press = function (opt_handler)\n````\n\n`opt_handler` fires once when the key is pressed by the user.  Only one handler\nfunction is allowed.  This is not a repeating state — it only fires once until\nthe user releases the key and presses it again.\n\nIf `opt_handler` is omitted, this function invokes whatever handler function\nwas previously bound with `kd.Key#press`.\n\n### Example\n\n````javascript\nkd.B.down(function () {\n  console.log('The \"B\" key is being held down!');\n});\n\nkd.B.up(function () {\n  console.log('The \"B\" key was released!');\n});\n\nkd.SPACE.press(function () {\n  console.log('The space bar was pressed!');\n});\n````\n\n-------------------------------------------------------------------------------\n\n````javascript\nkd.Key.prototype.unbindDown = function ()\n````\n\nUnbinds the function handler that was bound with `kd.Key#down`.\n\n````javascript\nkd.Key.prototype.unbindUp = function ()\n````\n\nUnbinds the function handler that was bound with `kd.Key#up`.\n\n````javascript\nkd.Key.prototype.unbindPress = function ()\n````\n\nUnbinds the function handler that was bound with `kd.Key#press`.\n\n### Example\n\n````javascript\nkd.B.down(function () {\n  console.log('The \"B\" key is being held down!');\n});\n\n// Now pressing the \"B\" key won't do anything\nkd.B.unbindDown();\n````\n\n-------------------------------------------------------------------------------\n\n### Helper methods\n\nThe `kd` Object has helper methods attached to it, and they are represented by\ncamelCase property names.\n\n````javascript\nkd.tick = function ()\n````\n\nCheck the states of all of the keys and invoke the necessary key handlers.  You\nshould call this once and only once somewhere in your run loop.  *If you don't\nhave this somewhere in your run loop, Keydrown won't do anything.*\n\n````javascript\n/**\n * @param {function} handler\n */\nkd.run = function (handler)\n````\n\nA basic run loop.  If your application already has a run loop, you don't need\nthis.  `kd.run` uses `requestAnimationFrame` if it is available, and falls back\nto a `setTimeout` loop if it is not.\n\n````javascript\nkd.stop = function ()\n````\n\nCancels the run loop started by `kd.run`.\n\n### Example\n\n````javascript\nkd.SPACE.down(function () {\n  console.log('The space bar is being held down!');\n});\n\nkd.ESC.down(function () {\n  console.log('Canceling the loop.');\n  kd.stop();\n});\n\nkd.run(function () {\n  kd.tick();\n});\n````\n\n-------------------------------------------------------------------------------\n\n### Getting the code\n\nIf you want to keep things simple, all you need is either `dist/keydrown.js` or\n`dist/keydrown.min.js` from this Git repo.  Alternatively, you can install\nKeydrown via [Bower](http://bower.io/):\n\n````\n$: bower install keydrown\n````\n\n### Module compatibility\n\nKeydrown always creates the `kd` browser global, but it can also be loaded as\nan AMD module or as a CommonJS/Node-like module (through a tool like\n[Browserify](http://browserify.org/)).\n\n````javascript\n// Loaded with an AMD loader (such as Require.js)\nrequire(['./path/to/keydrown'], function (kd) {\n  kd.run(function () {\n    kd.tick();\n  });\n});\n````\n\n````javascript\n// Loaded as a CommonJS module, after running it through Browserify or similar\nvar kd = require('./path/to/keydrown');\n\nkd.run(function () {\n  kd.tick();\n});\n````\n\n### Browser compatibility\n\nKeydrown supports all modern browsers, as well as Internet Explorer 7 and up\n(please see the [note below](#known-issues) about IE compatibility).\n\n### Known issues\n\nKeydrown has a feature where when the user blurs the browser window (for\nexample, switching to another application or tab), the key state is reset and\n\"down\" handlers stop firing.  This functionality is not supported in IE 7 and\n8, as there doesn't seem to be a way to bind to the `window`'s `blur` event\ncorrectly in those browsers.  You can assign a function to `window.onblur`, but\nthat function will only fire once IE regains focus, which is not sufficient for\nKeydrown's reset-on-blur functionality.\n",
  "readmeFilename": "README.md",
  "_id": "keydrown@0.1.4",
  "description": "## A JavaScript key state handler for web apps",
  "repository": {
    "type": "git",
    "url": "git://github.com/jeremyckahn/keydrown.git"
  }
}